# 04. 좋은 단위 테스트의 4대 요소

## 좋은 테스트는 무엇인가?

1. 개발주기에 통합되어 있다.
2. 코드 베이스의 가장 중요한 부분만을 대상으로 한다.
3. 최소한의 유지비로 최대 가치를 끌어낸다.

## 좋은 단위 테스트의 4대 요소

### 회귀 방지

- 테스트 중에 실행되는 코드의 양은 충분해야 한다.
- 복잡도가 높은 코드의 테스트 실행
- 코드의 도메인 유의성 : 수정되지 않은 부분(라이브러리 등)까지 확인

> 회귀 방지를 위해 가능한 많은 코드를 실행하는 것을 복표로 해야 한다.

### 리팩터링 내성

> # 리팩터링
> - 식별 가능한 동작이 변경되지 않고, 기존 코드를 변경하는 작업
> - 코드의 비 기능적 특징을 개선하는 것으로 가독성을 높이고 복잡도를 낮춘다.

- 리팩토링으로 인해 동작의 결과가 변하지 않았다면, 테스트 케이스의 결과도 변하지 않아야 한다.
  > # 거짓 양성
  > - 테스트 대상의 동작의 결과는 변하지 않았으나, 테스트 결과가 실패하는 경우
  > - 구현 세부 사항에 대한 미세한 테스트는 테스트 민감도가 높아져, 최종 결과가 동일하더라도 테스트는 실패하게 된다.
- 리팩토링 이후의 테스트는 조기 경고를 제공한다.
- 단위 테스트는 구현 세부사항의 절차에 집착하지 않고, 최종 결과의 정합성을 확인한다.

### 빠른 피드백

- 테스트 속도가 빠를수록 더 많은 테스트를 반복적으로 수행할 수 있다.
- 테스트가 실패한다면, 그 즉시 경고를 발생하고 피드백을 받는ㄷ.

### 유지 보수성

- 테스트가 얼마나 이해하기 어려운가?
    - 테스트 코드의 품질은 중요하다.
- 테스트가 얼마나 실행하기 어려운가?
    - 테스트가 프로세스 오부 종속성으로 작동하면, 각 의존관계를 해결하기 위해 많은 노력이 필요하다.
    - 이를 해결하기 위해 테스트 실행은 간편해야 한다.

> 신규 프로젝트를 개발하는 경우, 시간과 비용의 문제로 대부분의 개발자들은 테스트 코드의 중요성을 무시하게 된다.  
> 프로젝트의 운영 유지보수 단계에서, 기존 코드에 대한 단위/통합 테스트를 지속 전개하고자 한다면,  
> 테스트 코드를 기존 또는 신규 개발자에게 이해하기가 쉬워야 하고, 각 테스트는 독립적으로 구성되어 실행시 간섭이 없어야 한다.

### 회귀 방지와 리팩터링 내성 간의 관계

<table>
    <tr>
        <td colspan="2"></td>
        <td colspan="2">기능</td>
    </tr>
    <tr>
        <td colspan="2"></td>
        <td>작동</td>
        <td>고장</td>
    </tr>
    <tr>
        <td rowspan="2">테스트 결과</td>
        <td>테스트 통과</td>
        <td>올바른 추론<br/>(참 음성)</td>
        <td>2종 오류<br/>(거짓 음성)</td>
    </tr>
    <tr>
        <td>테스트 실패</td>
        <td>1종 오류<br/>(거짓 양성)</td>
        <td>올바른 추론<br/>(참 양성)</td>
    </tr>
</table>

- 참 음성
    - 테스트가 통과하고 기본 기능이 의도하는 대로 잘 작동하는 상황
- 참 양성
    - 기능이 고장나서 테스트가 실패하는 상황
- 거짓 음성
    - 기능이 고장났으나, 테스트가 통과하는 상황
    - 회귀 방지를 통해서 기능이 고장 났음을 알리는 것(즉, 거짓 음성을 최소화 하는 것)
- 거짓 양성
    - 기능은 올바르지만, 테스트가 실패하는 상황
    - 리팩터링 내성을 통해서 기능이 정상적인 것을 알리는 것(즉, 거짓 양성을 최소화 하는 것)
- 초기에는 새로운 기능을 추가하는 상황이 많고, 각 개발자의 소스에 대한 이해도가 높아지므로 거짓 음성을 최소화 하여야 한다.
- 이후, 시스템이 거대해지고, 코드가 복잡해 질수록, 코드의 리팩터링의 빈도수가 높아지므로 거짓 양성을 최소화해야한다.

## 테스트 사례

![02_Test_Example.png](02_Test_Example.png)

> End-to-End 테스트는 최종 사용자 관점에서 테스트를 진행하기 때문에 테스트를 위한 모든 구간을 통과하기 위한 소요시간이 길어져 빠른 피드백이 불가능하다.  
> 간단한 테스트는 항상 테스트를 통과하거나, 검증이 무의미한 경우가 많고 충분한 테스트 Coverage 를 달성하지 못한다.  
> 깨지기 쉬운 테스트는 테스트 코드와 운영 코드 간의 결합이 강하기 때문에 실제 동작상의 차이가 없더라도 테스트가 실패 할 수 있다.
> - 이상적인 테스트는 모든 범주의 상호 배타성으로 인해 전략적인 희생이 필요하다.
> - 리팩터링 내성과 유지보수성이 최대한 유지되도록 하고, 회귀방지와 빠른 피드백 사이에서 절충이 필요하다.
> - End-to-End 테스트는 회귀 방지에 유리하고, 단위 테스트는 빠른 피드백을 강조하며, 통합 테스트는 그 중간에 있다.

## 테스트 자동화

### 블랙박스 테스트와 화이트박스 테스트 간의 테스트 선택

- 블랙박스 테스트
    - 시스템의 내부 구조를 몰라도 시스템의 기능을 검사
    - 명세와 요구사항, 즉 App이 무엇을 해야하는지 중심으로 검증
    - 회귀 방지, 즉 테스트 검증 범위가 작아지더라도 명세 기반으로 기능 검증에 유리한 리팩터링 내성 지표에는 좋다.
- 화이트박스 테스트
    - App의 내부 작업을 검증하는 테스트 방식
    - 소스 코드에서 시작되어 App이 어떻게 해야 하는지 검증
    - 소스 코드 기반으로 철저한 테스트가 가능하여 회귀 방지에 유리하지만, 리팩터링 내성 지표에는 나쁘다.